'use client'

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react'

export type CartItem = {
  id: string
  product: {
    id: string
    name: string
    image: string
    price: number
    originalPrice?: number
    stock?: number
    minStockLevel?: number
    // DiÄŸer gerekli alanlar
  }
  size?: string
  color?: string
  quantity: number
}

interface CartContextType {
  items: CartItem[]
  addItem: (item: CartItem) => Promise<{ success: boolean; error?: string }>
  removeItem: (id: string, options?: { size?: string; color?: string }) => Promise<{ success: boolean; error?: string }>
  updateQuantity: (id: string, quantity: number, options?: { size?: string; color?: string }) => Promise<{ success: boolean; error?: string }>
  clearCart: () => Promise<{ success: boolean; error?: string }>
  getTotal: () => number
  getCount: () => number
  getSubtotal: () => number
  getDiscount: () => number
  getShippingCost: () => number
  loading: boolean
  error: string | null
}

const CartContext = createContext<CartContextType | undefined>(undefined)

export function useCart() {
  const ctx = useContext(CartContext)
  if (!ctx) throw new Error('useCart must be used within a CartProvider')
  return ctx
}

export function CartProvider({ children }: { children: ReactNode }) {
  const [items, setItems] = useState<CartItem[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [isHydrated, setIsHydrated] = useState(false) // âœ… Hydration kontrolÃ¼

  // YardÄ±mcÄ±: KullanÄ±cÄ± giriÅŸli mi? - SSR SAFE
  const isLoggedIn = () => {
    // ðŸ”§ REACT OFFICIAL: useEffect iÃ§inde kullan, render'da deÄŸil
    try {
      return !!window.localStorage.getItem('session_user')
    } catch {
      return false // SSR'da false dÃ¶ner
    }
  }

  // âœ… Hydration sonrasÄ± state'i gÃ¼ncelle
  useEffect(() => {
    setIsHydrated(true)
  }, [])

  // Stok kontrolÃ¼
  const validateStock = (quantity: number) => {
    // Mock stok kontrolÃ¼ - gerÃ§ek uygulamada API'den gelecek
    const maxStock = 10
    if (quantity > maxStock) {
      return { valid: false, error: `Bu Ã¼rÃ¼n iÃ§in maksimum ${maxStock} adet sipariÅŸ verebilirsiniz.` }
    }
    return { valid: true }
  }

  // Ä°lk yÃ¼klemede sepeti yÃ¼kle
  useEffect(() => {
    // ðŸ”§ REACT OFFICIAL: useEffect zaten client-side'da Ã§alÄ±ÅŸÄ±r
    // typeof window kontrolÃ¼ HYDRATION MISMATCH'e sebep oluyor!

    const loadCart = async () => {
      try {
        setError(null)
        if (isLoggedIn()) {
          // GiriÅŸli ise backend'den Ã§ek
          const response = await fetch('/api/cart')
          if (response.ok) {
            const data = await response.json()
            if (data && data.items) {
              setItems(data.items)
            }
          } else {
            console.error('Sepet yÃ¼klenemedi:', response.status)
            setError('Sepet yÃ¼klenirken hata oluÅŸtu')
          }
        } else {
          // GiriÅŸsiz ise localStorage'dan Ã§ek - SSR Safe
          try {
            const localCart = window.localStorage.getItem('cart')
            if (localCart) {
              let parsed = []
              try {
                parsed = JSON.parse(localCart)
              } catch (e) {
                console.error('LocalStorage sepet verisi bozuk:', e)
                parsed = []
              }
              // Filtrele: product ve product.id olmayanlarÄ± Ã§Ä±kar
              const valid = Array.isArray(parsed) ? parsed.filter(i => i && i.product && i.product.id) : []
              if (valid.length !== parsed.length) {
                // Bozuk veri varsa temizle
                window.localStorage.setItem('cart', JSON.stringify(valid))
              }
              setItems(valid)
            }
          } catch (localStorageError) {
            // SSR'da localStorage yok, sessizce devam et
            console.log('localStorage not available (SSR)')
          }
        }
      } catch (error) {
        console.error('Sepet yÃ¼kleme hatasÄ±:', error)
        setError('Sepet yÃ¼klenirken hata oluÅŸtu')
      } finally {
        setLoading(false)
      }
    }

    loadCart()
  }, [])

  // Sepeti localStorage'a kaydet (giriÅŸsiz) - SSR Safe
  const saveCartToLocal = (cartItems: CartItem[]) => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem('cart', JSON.stringify(cartItems))
      }
    } catch (error) {
      console.error('LocalStorage kaydetme hatasÄ±:', error)
      setError('Sepet kaydedilirken hata oluÅŸtu')
    }
  }

  // Sepete Ã¼rÃ¼n ekle
  const addItem = async (item: CartItem): Promise<{ success: boolean; error?: string }> => {
    try {
      setError(null)
      
      // Stok kontrolÃ¼
      const stockValidation = validateStock(item.quantity)
      if (!stockValidation.valid) {
        return { success: false, error: stockValidation.error || 'Stok kontrolÃ¼ baÅŸarÄ±sÄ±z' }
      }

      if (isLoggedIn()) {
        // Backend'e ekle
        const response = await fetch('/api/cart', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productId: item.id,
            quantity: item.quantity,
            size: item.size,
            color: item.color
          })
        })
        
        if (response.ok) {
          const data = await response.json()
          if (data && data.items) {
            setItems(data.items)
            return { success: true }
          }
        }
        
        return { success: false, error: 'ÃœrÃ¼n sepete eklenirken hata oluÅŸtu' }
      } else {
        // LocalStorage'a ekle
        setItems(prev => {
          // GÃ¼venli findIndex
          const idx = prev.findIndex(i => 
            i && i.product && i.product.id === item.product.id && 
            i.size === item.size && i.color === item.color
          )
          let newCart
          if (idx > -1) {
            newCart = [...prev]
            const existingItem = newCart[idx]
            if (existingItem) {
              existingItem.quantity += item.quantity
              // Stok kontrolÃ¼
              const stockValidation = validateStock(existingItem.quantity)
              if (!stockValidation.valid) {
                existingItem.quantity = 10 // Maksimum stok
              }
            }
          } else {
            newCart = [...prev, item]
          }
          saveCartToLocal(newCart)
          return newCart
        })
        return { success: true }
      }
    } catch (error) {
      console.error('Sepete ekleme hatasÄ±:', error)
      return { success: false, error: 'ÃœrÃ¼n sepete eklenirken hata oluÅŸtu' }
    }
  }

  // Sepetten Ã¼rÃ¼n Ã§Ä±kar
  const removeItem = async (id: string, options?: { size?: string; color?: string }): Promise<{ success: boolean; error?: string }> => {
    try {
      setError(null)
      
      if (isLoggedIn()) {
        // Backend'den Ã§Ä±kar
        const item = items.find(i => 
          i.product.id === id && 
          (!options?.size || i.size === options.size) && 
          (!options?.color || i.color === options.color)
        )
        if (!item) {
          return { success: false, error: 'ÃœrÃ¼n bulunamadÄ±' }
        }
        
        const response = await fetch('/api/cart', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ itemId: item.id })
        })
        
        if (response.ok) {
          setItems(items.filter(i => i.id !== item.id))
          return { success: true }
        }
        
        return { success: false, error: 'ÃœrÃ¼n sepetten Ã§Ä±karÄ±lÄ±rken hata oluÅŸtu' }
      } else {
        // LocalStorage'dan Ã§Ä±kar
        setItems(prev => {
          const newCart = prev.filter(i => 
            !(i.product.id === id && 
              (!options?.size || i.size === options.size) && 
              (!options?.color || i.color === options.color))
          )
          saveCartToLocal(newCart)
          return newCart
        })
        return { success: true }
      }
    } catch (error) {
      console.error('Sepetten Ã§Ä±karma hatasÄ±:', error)
      return { success: false, error: 'ÃœrÃ¼n sepetten Ã§Ä±karÄ±lÄ±rken hata oluÅŸtu' }
    }
  }

  // Sepet Ã¼rÃ¼n adedini gÃ¼ncelle
  const updateQuantity = async (id: string, quantity: number, options?: { size?: string; color?: string }): Promise<{ success: boolean; error?: string }> => {
    try {
      setError(null)
      
      if (quantity < 1) {
        return { success: false, error: 'Miktar en az 1 olmalÄ±dÄ±r' }
      }
      
      // Stok kontrolÃ¼
      const stockValidation = validateStock(quantity)
      if (!stockValidation.valid) {
        return { success: false, error: stockValidation.error || 'Stok kontrolÃ¼ baÅŸarÄ±sÄ±z' }
      }

      if (isLoggedIn()) {
        const item = items.find(i => 
          i.product.id === id && 
          (!options?.size || i.size === options.size) && 
          (!options?.color || i.color === options.color)
        )
        if (!item) {
          return { success: false, error: 'ÃœrÃ¼n bulunamadÄ±' }
        }
        
        const response = await fetch('/api/cart', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ itemId: item.id, quantity })
        })
        
        if (response.ok) {
          const updated = await response.json()
          if (updated) {
            setItems(items.map(i => 
              i.id === item.id ? { ...i, quantity: updated.quantity || i.quantity } : i
            ))
            return { success: true }
          }
        }
        
        return { success: false, error: 'Miktar gÃ¼ncellenirken hata oluÅŸtu' }
      } else {
        setItems(prev => {
          const newCart = prev.map(i =>
            i.product.id === id && 
            (!options?.size || i.size === options.size) && 
            (!options?.color || i.color === options.color)
              ? { ...i, quantity }
              : i
          )
          saveCartToLocal(newCart)
          return newCart
        })
        return { success: true }
      }
    } catch (error) {
      console.error('Miktar gÃ¼ncelleme hatasÄ±:', error)
      return { success: false, error: 'Miktar gÃ¼ncellenirken hata oluÅŸtu' }
    }
  }

  // Sepeti temizle (tÃ¼m Ã¼rÃ¼nleri sil)
  const clearCart = async (): Promise<{ success: boolean; error?: string }> => {
    try {
      setError(null)
      
      if (isLoggedIn()) {
        // Backend'den tÃ¼m Ã¼rÃ¼nleri sil
        const deletePromises = items.map(item =>
          fetch('/api/cart', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ itemId: item.id })
          })
        )
        
        await Promise.all(deletePromises)
        setItems([])
        return { success: true }
      } else {
        setItems([])
        saveCartToLocal([])
        return { success: true }
      }
    } catch (error) {
      console.error('Sepet temizleme hatasÄ±:', error)
      return { success: false, error: 'Sepet temizlenirken hata oluÅŸtu' }
    }
  }

  const getTotal = () => items.reduce((sum, i) => sum + i.product.price * i.quantity, 0)
  
  // âœ… Hydration-safe getCount - SSR'da her zaman 0, client'ta gerÃ§ek deÄŸer
  const getCount = () => {
    if (!isHydrated) return 0 // Server render'da her zaman 0
    return items.reduce((sum, i) => sum + i.quantity, 0)
  }
  
  const getSubtotal = () => getTotal()
  const getDiscount = () => 0 // Kupon indirimi burada hesaplanacak
  
  // Dinamik kargo Ã¼creti hesaplama
  const getShippingCost = () => {
    const subtotal = getTotal()
    
    // 2500â‚º Ã¼zeri alÄ±ÅŸveriÅŸlerde Ã¼cretsiz kargo
    if (subtotal >= 2500) return 0
    
    // Standart kargo Ã¼creti (en uygun PTT fiyatÄ± - %10 KDV dahil)
    return 76.89
  }

  return (
    <CartContext.Provider
      value={{ 
        items, 
        addItem, 
        removeItem, 
        updateQuantity, 
        clearCart, 
        getTotal, 
        getCount, 
        getSubtotal, 
        getDiscount, 
        getShippingCost,
        loading, 
        error 
      }}
    >
      {children}
    </CartContext.Provider>
  )
}
